<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stonks 图片合成</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            touch-action: none;
            /* 防止滚动干扰拖拽 */
        }

        #canvas-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            max-width: 100%;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: auto;
            touch-action: none;
            /* 允许拖拽 */
        }
    </style>
</head>

<body>
    <h2>Stonks 图片合成</h2>
    <input type="file" id="upload" multiple accept="image/*">
    <br><br>

    <label for="image-size">图片大小:</label>
    <input type="range" id="image-size" min="50" max="600" value="150">
    <span id="size-value">150</span>
    <br><br>
    <label for="export-format">导出格式:</label>
    <select id="export-format">
        <option value="image/png">PNG（无损）</option>
        <option value="image/jpeg">JPG（高质量）</option>
    </select>
    <br><br>
    <label for="use-bg">勾选-使用背景图片:</label>
    <input type="checkbox" id="use-bg" checked>
    <br><br>

    <label for="bg-color">可选背景颜色:</label>
    <input type="color" id="bg-color" value="#FF0000" disabled>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <button id="download">下载合成图片</button>



    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const upload = document.getElementById('upload');
        const download = document.getElementById('download');
        const imageSizeInput = document.getElementById('image-size');
        const sizeValue = document.getElementById('size-value');
        const useBgCheckbox = document.getElementById('use-bg');
        const bgColorPicker = document.getElementById('bg-color');

        let images = [];
        let imageSize = parseInt(imageSizeInput.value);
        let useBackgroundImage = useBgCheckbox.checked;
        let backgroundColor = bgColorPicker.value;
        let backgroundImage = new Image();
        backgroundImage.src = './img/bg.jpg';

        // 监听背景开关，启用/禁用颜色选择器
        useBgCheckbox.addEventListener('change', () => {
            useBackgroundImage = useBgCheckbox.checked;
            bgColorPicker.disabled = useBackgroundImage;
            drawImages();
        });

        // 监听背景颜色选择
        bgColorPicker.addEventListener('input', () => {
            backgroundColor = bgColorPicker.value;
            drawImages();
        });

        // 设置 canvas 适应屏幕
        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth * 0.9, 600);
            canvas.height = canvas.width;
            drawImages();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        imageSizeInput.addEventListener('input', (event) => {
            imageSize = parseInt(event.target.value);
            sizeValue.textContent = imageSize;
            drawImages();
        });

        upload.addEventListener('change', (event) => {
            const files = event.target.files;
            images = [];
            Array.from(files).forEach((file, index) => {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    images.push({ img, x: canvas.width / 2, y: canvas.height / 2 });
                    drawImages();
                };
            });
        });

        function drawImages() {
            // 先填充背景颜色或背景图片
            if (useBackgroundImage && backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // 再绘制上传的图片
            images.forEach(({ img, x, y }) => {
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(x, y, imageSize / 2, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, x - imageSize / 2, y - imageSize / 2, imageSize, imageSize);
                ctx.restore();
            });
        }

        let dragging = null;
        function startDrag(event) {
            const x = event.touches ? event.touches[0].clientX - canvas.getBoundingClientRect().left : event.offsetX;
            const y = event.touches ? event.touches[0].clientY - canvas.getBoundingClientRect().top : event.offsetY;
            dragging = images.find(({ x: imgX, y: imgY }) => Math.hypot(x - imgX, y - imgY) <= imageSize / 2);
        }
        function moveDrag(event) {
            if (dragging) {
                event.preventDefault();
                const x = event.touches ? event.touches[0].clientX - canvas.getBoundingClientRect().left : event.offsetX;
                const y = event.touches ? event.touches[0].clientY - canvas.getBoundingClientRect().top : event.offsetY;
                dragging.x = x;
                dragging.y = y;
                drawImages();
            }
        }
        function stopDrag() { dragging = null; }

        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', moveDrag);
        canvas.addEventListener('mouseup', stopDrag);
        canvas.addEventListener('mouseleave', stopDrag);
        canvas.addEventListener('touchstart', startDrag, { passive: false });
        canvas.addEventListener('touchmove', moveDrag, { passive: false });
        canvas.addEventListener('touchend', stopDrag);

        const exportFormat = document.getElementById('export-format');

        download.addEventListener('click', () => {
            const format = exportFormat.value; // 读取用户选择的格式
            const quality = format === 'image/jpeg' ? 0.95 : 1.0; // PNG 无需质量参数，JPEG 设为 0.95

            canvas.toBlob((blob) => {
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = format === 'image/png' ? 'merged-image.png' : 'merged-image.jpg';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, format, quality);
        });
    </script>
</body>

</html>